<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <title>fusite2 - 標高タイル可視化</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="国土地理院の標高データを WebP Terrarium タイルとして可視化 - 拡張版" />

    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@5.7.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@5.7.0/dist/maplibre-gl.css" rel="stylesheet" />

    <!-- maplibre-contour for contour theme -->
    <script src="https://unpkg.com/maplibre-contour@0.0.5/dist/index.min.js"></script>

    <link href="style.css" rel="stylesheet" />
</head>

<body class="has-info-toggle">
    <div id="map"></div>

    <button id="info-toggle" class="info-toggle" aria-expanded="false" aria-controls="info-panel" title="情報を開く">ℹ️</button>

    <div id="info-panel" class="info-panel hidden" aria-hidden="true">
        <h1>fusite2</h1>
        <p id="info-description">国土地理院の標高データを Terrarium 形式で可視化</p>
        
        <div class="control-group">
            <label for="theme-select">テーマ:</label>
            <select id="theme-select">
                <option value="osm">OSM</option>
                <option value="gsi">GSI</option>
                <option value="gsi-ortho">地理院オルソ</option>
                <option value="contour">等高線</option>
                <option value="lineage">元データ</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="terrain-select">地形:</label>
            <select id="terrain-select">
                <option value="fusi">fusi</option>
                <option value="iwaki">iwaki</option>
                <option value="shimabara">shimabara</option>
            </select>
        </div>
        
        <p class="attribution">
            データ: <a href="https://www.gsi.go.jp/" target="_blank" rel="noopener noreferrer">国土地理院 (GSI Japan)</a><br>
            測量法に基づく国土地理院長承認（使用）R 6JHs 133<br>
            <br>
            Inspired by <a href="https://github.com/mapterhorn/mapterhorn" target="_blank"
                rel="noopener noreferrer">Mapterhorn</a><br>
            Made with <a href="https://github.com/hfu/fusite2" target="_blank" rel="noopener noreferrer">fusite2</a>
        </p>
    </div>

    <script type="text/javascript">
        /**
         * Parse URL fragment parameters
         * Format: #map=z/lat/lng&terrain=xxx&theme=yyy
         */
        function parseHashParams() {
            const hash = window.location.hash.substring(1);
            const params = {};

            if (!hash) return params;

            // Split by & and parse each parameter
            hash.split('&').forEach(part => {
                const [key, value] = part.split('=');
                if (key && value !== undefined) {
                    params[key] = value;
                }
            });

            return params;
        }

        /**
         * Update URL fragment without triggering hashchange.
         *
         * This uses `history.replaceState` to update only the fragment/hash
         * without causing a navigation. Use this when you want the URL to
         * reflect UI state but do not want to add a new history entry or
         * trigger a `hashchange` navigation.
         */
        function updateHashParams(newParams) {
            const currentParams = parseHashParams();
            const mergedParams = { ...currentParams, ...newParams };

            const hashParts = [];
            for (const [key, value] of Object.entries(mergedParams)) {
                if (value !== undefined && value !== null) {
                    hashParts.push(`${key}=${value}`);
                }
            }

            const newHash = hashParts.join('&');
            if (window.location.hash.substring(1) !== newHash) {
                history.replaceState(null, '', '#' + newHash);
            }
        }

        // Parse initial parameters
        let hashParams = parseHashParams();
        let terrain = hashParams.terrain || 'fusi';
        let theme = hashParams.theme || 'osm';
        let exag = parseFloat(hashParams.exag) || 1;

        // Helper to construct TileJSON URL for a given terrain
        function getTerrainTileJsonUrl(terrainName) {
            return `https://tunnel.optgeo.org/martin/${terrainName}`;
        }

        // Global map reference so other functions can update the map dynamically
        let map = null;

        /**
         * Build the style object based on theme and terrain
         */
        async function buildStyle(terrainTileJsonUrl, theme, exaggeration) {
            // Fetch TileJSON for terrain (DEM source). Always use the
            // original terrain TileJSON (e.g. /martin/iwaki) to build the
            // raster-dem source. For the `lineage` theme we'll separately
            // fetch the `{terrain}-lineage` TileJSON for imagery tiles.
            let terrainTiles;
            try {
                const response = await fetch(terrainTileJsonUrl);
                if (!response.ok) {
                    throw new Error(`Failed to fetch TileJSON: ${response.status}`);
                }
                const tileJson = await response.json();
                terrainTiles = tileJson.tiles;
            } catch (error) {
                console.error('Error fetching TileJSON for terrain:', error);
                // Fallback to default tile URL pattern
                terrainTiles = [`${terrainTileJsonUrl}/{z}/{x}/{y}`];
            }

            const style = {
                version: 8,
                glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf',
                sources: {
                    terrainSource: {
                            type: 'raster-dem',
                            tiles: terrainTiles,
                            encoding: 'terrarium',
                            tileSize: 512,
                            minzoom: 0,
                            maxzoom: 16
                        },
                    // Separate source for hillshade layers to avoid using the same
                    // source object for both 3D terrain and hillshade rendering.
                    // Using two sources (even pointing to the same tiles) improves
                    // rendering quality and avoids MapLibre warnings.
                    hillshadeSource: {
                            type: 'raster-dem',
                            tiles: terrainTiles,
                            encoding: 'terrarium',
                            tileSize: 512,
                            minzoom: 0,
                            maxzoom: 16
                        }
                },
                layers: [],
                terrain: {
                    source: 'terrainSource',
                    exaggeration: exaggeration
                }
            };

            // Add theme-specific sources and layers
            if (theme === 'osm') {
                return buildOsmStyle(style);
            } else if (theme === 'gsi') {
                return buildGsiStyle(style);
            } else if (theme === 'gsi-ortho') {
                return buildGsiOrthoStyle(style);
            } else if (theme === 'contour') {
                return buildContourStyle(style, terrainTiles[0]);
            } else if (theme === 'lineage') {
                // Attempt to fetch the TileJSON that explicitly lists lineage
                // imagery tiles (e.g. /martin/iwaki-lineage). If that fails,
                // fall back to a heuristic transformation of the terrain
                // tile URLs by inserting `-lineage` into the path.
                const lineageTileJsonUrl = terrainTileJsonUrl + '-lineage';
                let lineageTiles;
                try {
                    const resp = await fetch(lineageTileJsonUrl);
                    if (!resp.ok) throw new Error(`Failed to fetch lineage TileJSON: ${resp.status}`);
                    const tj = await resp.json();
                    lineageTiles = tj.tiles;
                    // If TileJSON provides metadata, propagate it to the source
                    var lineageTileSize = tj.tileSize || tj.tilesize || tj.tilesize || 256;
                    var lineageMaxzoom = tj.maxzoom || tj.maxZoom || tj.maxZoom || 19;
                    var lineageAttribution = tj.attribution || tj.attribution || '';
                } catch (e) {
                    console.warn('Failed to fetch lineage TileJSON, falling back to heuristic tile URLs:', e);
                    // Derive terrain name from the provided TileJSON URL
                    const m = terrainTileJsonUrl.match(/\/([^\/\?#]+)\/?$/);
                    const terrainName = m ? m[1] : null;
                    lineageTiles = terrainTiles.map(t => {
                        if (terrainName) {
                            try {
                                const esc = terrainName.replace(/[.*+?^${}()|[\\]\\]/g, '\\\\$&');
                                const re = new RegExp('/' + esc + '(?=/|$)');
                                return t.replace(re, '/' + terrainName + '-lineage');
                            } catch (err) {
                                return t + '';
                            }
                        }
                        return t + '-lineage';
                    });
                }

                // Add raster source for lineage imagery. If we were able to
                // fetch the TileJSON, prefer its `tiles`, `tileSize` and
                // `maxzoom` values; otherwise fall back to sensible defaults.
                style.sources.lineage = {
                    type: 'raster',
                    tiles: lineageTiles,
                    tileSize: typeof lineageTileSize !== 'undefined' ? lineageTileSize : 256,
                    maxzoom: typeof lineageMaxzoom !== 'undefined' ? lineageMaxzoom : 19,
                    attribution: typeof lineageAttribution !== 'undefined' ? lineageAttribution : undefined
                };

                style.layers = [
                    {
                        id: 'background',
                        type: 'background',
                        paint: {
                            'background-color': '#e0e0e0'
                        }
                    },
                    {
                        id: 'lineage',
                        type: 'raster',
                        source: 'lineage',
                        paint: {
                            'raster-opacity': 1.0
                        }
                    },
                    {
                        id: 'hillshade',
                        type: 'hillshade',
                        source: 'hillshadeSource',
                        paint: {
                            'hillshade-exaggeration': 0.3,
                            'hillshade-shadow-color': '#473B24'
                        }
                    }
                ];

                style.sky = {
                    'sky-color': '#87CEEB',
                    'sky-horizon-blend': 0.5,
                    'horizon-color': '#ffffff',
                    'horizon-fog-blend': 0.5,
                    'fog-color': '#ffffff',
                    'fog-ground-blend': 0.5
                };

                return style;
            }

            // Default to osm
            return buildOsmStyle(style);
        }

        /**
         * OSM theme style (reproduces osm.html)
         */
        function buildOsmStyle(style) {
            style.sources.osm = {
                type: 'raster',
                tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                tileSize: 256,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxzoom: 19
            };

            style.layers = [
                {
                    id: 'background',
                    type: 'background',
                    paint: {
                        'background-color': '#e0e0e0'
                    }
                },
                {
                    id: 'osm',
                    type: 'raster',
                    source: 'osm',
                    paint: {
                        'raster-opacity': 0.7
                    }
                },
                {
                    id: 'hillshade',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    paint: {
                        'hillshade-exaggeration': 0.3,
                        'hillshade-shadow-color': '#473B24'
                    }
                }
            ];

            style.sky = {
                'sky-color': '#87CEEB',
                'sky-horizon-blend': 0.5,
                'horizon-color': '#ffffff',
                'horizon-fog-blend': 0.5,
                'fog-color': '#ffffff',
                'fog-ground-blend': 0.5
            };

            return style;
        }

        /**
         * GSI theme style (reproduces index.html with bvmap)
         */
        function buildGsiStyle(style) {
            style.sources.bvmap = {
                type: 'vector',
                url: 'https://tunnel.optgeo.org/martin/bvmap'
            };

            style.layers = [
                {
                    id: 'background',
                    type: 'background',
                    paint: {
                        'background-color': '#e0e0e0'
                    }
                },
                {
                    id: 'hillshade',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    paint: {
                        'hillshade-exaggeration': 0.2,
                        'hillshade-highlight-color': 'rgb(255,255,235)',
                        'hillshade-shadow-color': 'rgb(110,120,130)'
                    }
                },
                {
                    id: '行政区画',
                    type: 'fill',
                    source: 'bvmap',
                    'source-layer': 'AdmArea',
                    paint: {
                        'fill-color': 'rgba(255,255,255,0)',
                        'fill-outline-color': 'rgba(110,120,130,1)'
                    }
                },
                {
                    id: '水域',
                    maxzoom: 17,
                    type: 'fill',
                    source: 'bvmap',
                    'source-layer': 'WA',
                    paint: {
                        'fill-color': 'rgba(0,0,0,0)',
                        'fill-outline-color': 'rgba(110,120,130,1)'
                    }
                },
                {
                    id: '地形表記面',
                    type: 'fill',
                    source: 'bvmap',
                    maxzoom: 17,
                    'source-layer': 'TpgphArea',
                    paint: {
                        'fill-color': 'rgba(0,0,0,0)',
                        'fill-outline-color': 'rgba(110,120,130,1)'
                    }
                },
                {
                    id: '地形表記面2',
                    type: 'fill',
                    source: 'bvmap',
                    'source-layer': 'TpgphArea',
                    minzoom: 17,
                    filter: [
                        'in',
                        ['get', 'vt_flag17'],
                        ['literal', [1, 2]]
                    ],
                    paint: {
                        'fill-color': 'rgba(0,0,0,0)',
                        'fill-outline-color': 'rgba(110,120,130,1)'
                    }
                },
                {
                    id: '海岸線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'Cstline',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '河川_線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'RvrCL',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '水涯線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'WL',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '水部表記線polygon',
                    type: 'fill',
                    source: 'bvmap',
                    'source-layer': 'WRltLine',
                    filter: [
                        '==',
                        ['geometry-type'],
                        'Polygon'
                    ],
                    paint: {
                        'fill-color': 'rgba(255,255,255,0)',
                        'fill-outline-color': 'rgba(110,120,130,1)'
                    }
                },
                {
                    id: '水部表記線line',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'WRltLine',
                    filter: [
                        '==',
                        ['geometry-type'],
                        'LineString'
                    ],
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '行政区画界線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'AdmBdry',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '等深線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'Isbt',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '水部構造物面',
                    type: 'fill',
                    source: 'bvmap',
                    'source-layer': 'WStrA',
                    paint: {
                        'fill-color': 'rgba(0,0,0,0)',
                        'fill-outline-color': 'rgba(110,120,130,1)'
                    }
                },
                {
                    id: '水部構造物線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'WStrL',
                    maxzoom: 17,
                    filter: [
                        'any',
                        ['!', ['has', 'vt_flag17']],
                        ['in', ['get', 'vt_flag17'], ['literal', [0, 1]]]
                    ],
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '水部構造物線2',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'WStrL',
                    minzoom: 17,
                    filter: [
                        'in',
                        ['get', 'vt_flag17'],
                        ['literal', [1, 2]]
                    ],
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '道路_線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'RdCL',
                    maxzoom: 17,
                    paint: {
                        'line-color': [
                            'case',
                            ['==', ['get', 'vt_rnkwidth'], '不明'],
                            'rgba(255,255,255,0)',
                            'rgba(110,120,130,1)'
                        ],
                        'line-width': 1
                    }
                },
                {
                    id: '道路_線2',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'RdCL',
                    minzoom: 17,
                    filter: [
                        'all',
                        ['in', ['get', 'vt_flag17'], ['literal', [1, 2]]]
                    ],
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '鉄道_線',
                    maxzoom: 17,
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'RailCL',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '鉄道_線2',
                    minzoom: 17,
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'RailCL',
                    filter: [
                        'all',
                        ['in', ['get', 'vt_flag17'], ['literal', [1, 2]]]
                    ],
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '建築物_外周線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'BldA',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '地下駅',
                    type: 'fill',
                    source: 'bvmap',
                    'source-layer': 'UndergroundStation',
                    paint: {
                        'fill-color': 'rgba(0,0,0,0)',
                        'fill-outline-color': 'rgba(110,120,130,1)'
                    }
                },
                {
                    id: '道路縁',
                    minzoom: 17,
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'RdEdg',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '道路構成線',
                    minzoom: 17,
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'RdCompt',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '軌道_線',
                    minzoom: 17,
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'RailTrCL',
                    layout: {
                        'line-sort-key': ['get', 'vt_drworder']
                    },
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '特定地区界',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'SpcfArea',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '構造物面',
                    type: 'fill',
                    source: 'bvmap',
                    'source-layer': 'StrctArea',
                    paint: {
                        'fill-color': 'rgba(0,0,0,0)',
                        'fill-outline-color': 'rgba(110,120,130,1)'
                    }
                },
                {
                    id: '構造物面の外周線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'StrctArea',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '構造物線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'StrctLine',
                    minzoom: 17,
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '交通トンネル口',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'TrfTnnlEnt',
                    minzoom: 17,
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                },
                {
                    id: '送電線',
                    type: 'line',
                    source: 'bvmap',
                    'source-layer': 'PwrTrnsmL',
                    paint: {
                        'line-color': 'rgba(110,120,130,1)',
                        'line-width': 1
                    }
                }
            ];

            return style;
        }

        /**
         * GSI Ortho theme style (seamlessphoto)
         */
        function buildGsiOrthoStyle(style) {
            style.sources['gsi-ortho'] = {
                type: 'raster',
                tiles: ['https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg'],
                tileSize: 256,
                attribution: '&copy; <a href="https://www.gsi.go.jp/" target="_blank" rel="noopener noreferrer">国土地理院</a>',
                maxzoom: 18
            };

            style.layers = [
                {
                    id: 'background',
                    type: 'background',
                    paint: {
                        'background-color': '#e0e0e0'
                    }
                },
                {
                    id: 'gsi-ortho',
                    type: 'raster',
                    source: 'gsi-ortho',
                    paint: {
                        'raster-opacity': 1.0
                    }
                },
                {
                    id: 'hillshade',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    paint: {
                        'hillshade-exaggeration': 0.3,
                        'hillshade-shadow-color': '#473B24'
                    }
                }
            ];

            style.sky = {
                'sky-color': '#87CEEB',
                'sky-horizon-blend': 0.5,
                'horizon-color': '#ffffff',
                'horizon-fog-blend': 0.5,
                'fog-color': '#ffffff',
                'fog-ground-blend': 0.5
            };

            return style;
        }

        /**
         * Contour theme style (reproduces contour.html)
         */
        function buildContourStyle(style, terrainTileUrl) {
            // Setup DEM source for contour generation
            const demSource = new mlcontour.DemSource({
                url: terrainTileUrl,
                encoding: 'terrarium',
                tileSize: 512,
                maxzoom: 16,
                worker: true
            });
            demSource.setupMaplibre(maplibregl);

            style.sources.contourSource = {
                type: 'vector',
                tiles: [
                    demSource.contourProtocolUrl({
                        thresholds: {
                            11: [50, 500],
                            12: [20, 200],
                            13: [10, 100],
                            14: [5, 50],
                            15: [2, 20],
                            16: [1, 10]
                        },
                        elevationKey: 'ele',
                        levelKey: 'level',
                        contourLayer: 'contours',
                        buffer: 4,
                        overzoom: 2
                    })
                ],
                maxzoom: 17
            };

            style.layers = [
                {
                    id: 'background',
                    type: 'background',
                    paint: {
                        'background-color': '#e0e0e0'
                    }
                },
                {
                    id: 'hillshade',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    paint: {
                        'hillshade-exaggeration': 0.2,
                        'hillshade-highlight-color': 'rgb(255,255,235)',
                        'hillshade-shadow-color': 'rgb(110,120,130)'
                    }
                },
                {
                    id: 'contours',
                    type: 'line',
                    source: 'contourSource',
                    'source-layer': 'contours',
                    paint: {
                        'line-color': 'rgb(215,151,60)',
                        'line-width': [
                            'interpolate', ['linear'], ['zoom'],
                            11, ['match', ['get', 'level'], 1, 0.8, 0.4],
                            14, ['match', ['get', 'level'], 1, 1.2, 0.6],
                            16, ['match', ['get', 'level'], 1, 1.5, 0.7]
                        ],
                        'line-opacity': 0.95
                    },
                    layout: {
                        'line-cap': 'round',
                        'line-join': 'round'
                    }
                }
            ];

            return style;
        }

        /**
         * Parse map hash (z/lat/lng/pitch/bearing) from URL
         */
        function parseMapHash(mapParam) {
            if (!mapParam) return null;
            
            const parts = mapParam.split('/');
            if (parts.length < 3) return null;

            const result = {
                zoom: parseFloat(parts[0]),
                center: [parseFloat(parts[2]), parseFloat(parts[1])]
            };

            if (parts.length >= 4) {
                result.pitch = parseFloat(parts[3]);
            }
            if (parts.length >= 5) {
                result.bearing = parseFloat(parts[4]);
            }

            return result;
        }

        /**
         * Format map position to hash string
         */
        function formatMapHash(zoom, center, pitch, bearing) {
            const z = zoom.toFixed(2);
            const lat = center.lat.toFixed(5);
            const lng = center.lng.toFixed(5);
            const p = pitch.toFixed(1);
            const b = bearing.toFixed(0);
            return `${z}/${lat}/${lng}/${p}/${b}`;
        }

        // Initialize map
        async function initMap() {
            const style = await buildStyle(getTerrainTileJsonUrl(terrain), theme, exag);

            // Parse initial map position from hash
            const mapPosition = parseMapHash(hashParams.map);

            const mapOptions = {
                container: 'map',
                style: style,
                maxPitch: 85,
                projection: 'globe'
            };

            // Set initial position from hash or default
            if (mapPosition) {
                mapOptions.zoom = mapPosition.zoom;
                mapOptions.center = mapPosition.center;
                if (mapPosition.pitch !== undefined) {
                    mapOptions.pitch = mapPosition.pitch;
                }
                if (mapPosition.bearing !== undefined) {
                    mapOptions.bearing = mapPosition.bearing;
                }
            } else {
                // Default position (same as original fusite)
                mapOptions.zoom = 14.74;
                mapOptions.center = [129.87255, 32.75055];
                mapOptions.pitch = 16.2;
                mapOptions.bearing = 6;
            }

            map = new maplibregl.Map(mapOptions);

            // Add navigation controls
            map.addControl(new maplibregl.NavigationControl({
                visualizePitch: true,
                showZoom: true,
                showCompass: true
            }), 'top-right');

            // Add scale control
            map.addControl(new maplibregl.ScaleControl({
                maxWidth: 200,
                unit: 'metric'
            }), 'bottom-right');

            // Add fullscreen control
            map.addControl(new maplibregl.FullscreenControl(), 'top-right');

            // Add geolocate control
            map.addControl(new maplibregl.GeolocateControl({
                positionOptions: {
                    enableHighAccuracy: true
                },
                trackUserLocation: true
            }), 'top-right');

            // Add native Globe control
            map.addControl(new maplibregl.GlobeControl(), 'top-right');

            // Custom Terrain Exaggeration Control
            class TerrainExaggerationControl {
                constructor(initialValue) {
                    this._initialValue = initialValue;
                }

                onAdd(map) {
                    this._map = map;
                    this._container = document.createElement('div');
                    this._container.className = 'maplibregl-ctrl terrain-ctrl';
                    this._container.innerHTML = `
                        <div class="terrain-exaggeration">
                            <label for="terrain-slider">地形強調: <span id="terrain-value">${this._initialValue.toFixed(1)}</span>x</label>
                            <input type="range" id="terrain-slider" min="0" max="3" step="0.1" value="${this._initialValue}">
                        </div>
                    `;

                    const slider = this._container.querySelector('#terrain-slider');
                    const valueDisplay = this._container.querySelector('#terrain-value');

                    slider.oninput = (e) => {
                        const value = parseFloat(e.target.value);
                        valueDisplay.textContent = value.toFixed(1);
                        map.setTerrain({
                            source: 'terrainSource',
                            exaggeration: value
                        });
                        // Update URL with new exaggeration value
                        updateHashParams({
                            exag: value.toFixed(1)
                        });
                    };

                    return this._container;
                }

                onRemove() {
                    this._container.parentNode.removeChild(this._container);
                    this._map = undefined;
                }
            }

            // Add Terrain Exaggeration control
            map.addControl(new TerrainExaggerationControl(exag), 'bottom-left');

            // Helper function to get current exaggeration from slider
            function getCurrentExaggeration() {
                const slider = document.getElementById('terrain-slider');
                return slider ? parseFloat(slider.value) : exag;
            }

            // Update hash when map moves (using 'map' key as specified)
            map.on('moveend', () => {
                const center = map.getCenter();
                const zoom = map.getZoom();
                const pitch = map.getPitch();
                const bearing = map.getBearing();
                const currentExag = getCurrentExaggeration();
                
                updateHashParams({
                    map: formatMapHash(zoom, center, pitch, bearing),
                    terrain: terrain,
                    theme: theme,
                    exag: currentExag.toFixed(1)
                });
            });

            // Add GSI attribution on load
            map.on('load', () => {
                console.log(`Map loaded with theme: ${theme}, terrain: ${terrain}, exag: ${exag}`);

                const attributionControl = document.querySelector('.maplibregl-ctrl-attrib-inner');
                if (attributionControl && !attributionControl.innerHTML.includes('国土地理院')) {
                    attributionControl.innerHTML += ' | データ: <a href="https://www.gsi.go.jp/" target="_blank" rel="noopener noreferrer">国土地理院 (GSI Japan)</a> R 6JHs 133';
                }

                // Update info panel description based on theme
                const infoDesc = document.getElementById('info-description');
                if (theme === 'contour') {
                    infoDesc.textContent = 'Terrarium 標高タイルから動的に等高線を生成';
                } else if (theme === 'gsi') {
                    infoDesc.textContent = '国土地理院の標高データと基盤地図を表示';
                } else if (theme === 'gsi-ortho') {
                    infoDesc.textContent = '国土地理院のシームレス写真タイルと標高データを表示';
                } else if (theme === 'lineage') {
                    infoDesc.textContent = '地形に対応した Lineage 画像タイルを表示（terrain に "-lineage" を付加したタイル）';
                } else {
                    infoDesc.textContent = '国土地理院の標高データを Terrarium 形式で可視化';
                }

                // Set initial hash if not already set
                if (!hashParams.map) {
                    const center = map.getCenter();
                    const zoom = map.getZoom();
                    const pitch = map.getPitch();
                    const bearing = map.getBearing();
                    const currentExag = getCurrentExaggeration();
                    
                    updateHashParams({
                        map: formatMapHash(zoom, center, pitch, bearing),
                        terrain: terrain,
                        theme: theme,
                        exag: currentExag.toFixed(1)
                    });
                }
            });

            map.on('error', (e) => {
                console.error('Map error:', e);
            });
        }

        // Info panel toggle
        const toggleBtn = document.getElementById('info-toggle');
        const infoPanel = document.getElementById('info-panel');
        const updateToggleUi = () => {
            const isOpen = !infoPanel.classList.contains('hidden');
            toggleBtn.setAttribute('aria-expanded', String(isOpen));
            infoPanel.setAttribute('aria-hidden', String(!isOpen));
            toggleBtn.textContent = isOpen ? '×' : 'ℹ️';
            toggleBtn.title = isOpen ? '情報を閉じる' : '情報を開く';
        };
        toggleBtn.addEventListener('click', () => {
            infoPanel.classList.toggle('hidden');
            updateToggleUi();
        });
        updateToggleUi();

        // Initialize dropdowns with current values
        const themeSelect = document.getElementById('theme-select');
        const terrainSelect = document.getElementById('terrain-select');
        
        themeSelect.value = theme;
        terrainSelect.value = terrain;

        /**
         * Update URL fragment and apply changes without full reload.
         * This updates the hash (via history.replaceState) and then
         * rebuilds/applies the map style so theme/terrain changes take effect
         * immediately.
         */
        async function updateAndApply(newTheme, newTerrain) {
            // Build merged params and new hash
            const currentParams = parseHashParams();
            const mergedParams = {
                ...currentParams,
                theme: newTheme,
                terrain: newTerrain
            };

            const hashParts = [];
            for (const [key, value] of Object.entries(mergedParams)) {
                if (value !== undefined && value !== null) {
                    hashParts.push(`${key}=${value}`);
                }
            }

            const newHash = hashParts.join('&');
            // Update the URL fragment without creating a history entry
            history.replaceState(null, '', '#' + newHash);

            // Re-parse and apply to map
            await applyHashParamsToMap();
        }

        /**
         * Read the current hash params and apply the theme/terrain/exag to the map
         * without performing a full page reload. This will rebuild the style and
         * call `map.setStyle` so MapLibre updates visuals accordingly.
         */
        async function applyHashParamsToMap() {
            if (!map) return;

            hashParams = parseHashParams();
            terrain = hashParams.terrain || terrain;
            theme = hashParams.theme || theme;
            exag = parseFloat(hashParams.exag) || exag;

            // Update dropdown UI to reflect current params
            if (typeof themeSelect !== 'undefined' && themeSelect) themeSelect.value = theme;
            if (typeof terrainSelect !== 'undefined' && terrainSelect) terrainSelect.value = terrain;

            // Build and apply new style.
            // Note: `map.setStyle` replaces the current style (sources and
            // layers). UI controls added via `map.addControl` are usually
            // retained by MapLibre, but style-specific resources (sources,
            // layers) are reconstructed. This approach avoids a full page
            // reload while ensuring the visual style updates to the new
            // `theme`/`terrain` settings.
            const style = await buildStyle(getTerrainTileJsonUrl(terrain), theme, exag);
            map.setStyle(style);

            // Update info description to reflect new theme immediately
            const infoDesc = document.getElementById('info-description');
            if (infoDesc) {
                if (theme === 'contour') {
                    infoDesc.textContent = 'Terrarium 標高タイルから動的に等高線を生成';
                } else if (theme === 'gsi') {
                    infoDesc.textContent = '国土地理院の標高データと基盤地図を表示';
                } else if (theme === 'gsi-ortho') {
                    infoDesc.textContent = '国土地理院のシームレス写真タイルと標高データを表示';
                } else if (theme === 'lineage') {
                    infoDesc.textContent = '地形に対応した Lineage 画像タイルを表示（terrain に "-lineage" を付加したタイル）';
                } else {
                    infoDesc.textContent = '国土地理院の標高データを Terrarium 形式で可視化';
                }
            }
        }

        // Event handlers for dropdown changes: update fragment and apply without reload
        themeSelect.addEventListener('change', (e) => {
            updateAndApply(e.target.value, terrain);
        });

        terrainSelect.addEventListener('change', (e) => {
            updateAndApply(theme, e.target.value);
        });

        // Also respond to external hash changes (e.g., user pasted URL)
        window.addEventListener('hashchange', () => {
            applyHashParamsToMap();
        });

        // Initialize the map
        initMap();
    </script>
</body>

</html>
